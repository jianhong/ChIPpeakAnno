---
title: "ChIPpeakAnno: annotate, visualize, and compare peak data"
author:
- name: Jianhong Ou
  affiliation: Duke Univeristy, Durham, USA
- name: Kai Hu
  affiliation: UMass Chan Medical School, Worcester, USA
- name: Jun Yu
  affiliation: Novo Nordisk Dicerna TRU, Boston, USA
- name: Lihua Julie Zhu
  affiliation: UMass Chan Medical School, Worcester, USA
output:
  BiocStyle::html_document:
    toc_float: true
    pandoc_args: "--citeproc"
  BiocStyle::pdf_document: default
package: ChIPpeakAnno
link-citations: yes
bibliography: bibliography.bib
abstract: |
  A guide to utilizing `r Biocpkg("ChIPpeakAnno")` [@zhu2010; @zhu2013] for common analysis of [peak calling](https://en.wikipedia.org/wiki/Peak_calling) data identified with the classic [ChIP-seq](https://en.wikipedia.org/wiki/ChIP_sequencing) or the cutting-edge [CUT&RUN](https://en.wikipedia.org/wiki/CUT%26Tag_sequencing) experiments and their variants. `r Biocpkg("ChIPpeakAnno")` offers a range of functions for peak annotaion (the process of mapping peaks to the nearest genomic features such as gene and miRNA), visualization, and peak profile comparison.
vignette: |
  %\VignetteIndexEntry{ChIPpeakAnno: annotate, visualize, and compare peak data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r setup, include = FALSE}
knitr::opts_chunk$set(message = FALSE, 
                      warning = FALSE,
          					  tidy = FALSE, 
          					  fig.width = 6, 
          					  fig.height = 4,
          					  fig.align = "center")
                      # fig.small = TRUE

# for dev only:
devtools::load_all("~/dropbox/Project/UMMS/Github/JunhuiLi1017/ChIPpeakAnno")
```

# Introduction
Several experimental techniques including ChIP-ChIP [@blat1999], ChIP-seq [@barski2007; @johnson2007], CUT&RUN [@skene2017] have gained widespread use in molecular biology. These techniques enable the study of protein-DNA interactions by identifying the genomic regions that are associated with specific proteins, such as transcription factor binding sites, or epigenetic markers like histone modification. Through these approaches, researchers gain valuable insights into the regulation of genes and the structure of chromatin.

The analysis of experimental data involves several key steps, which are outlined below. The steps where the `r Biocpkg("ChIPpeakAnno")` package can be utilized are displayed in **bold**.

+ Quality control and preprocessing
+ Read alignment (does not apply to ChIP-ChIP)
+ Peak calling: identify the genomic regions of significant enrichment (peaks), that represent the binding sites of the protein of epigenetic marker of interest
+ **Peak annotation**: associate peaks with nearby genomic features, usually genes, to understand their functional implications
+ **Functional enrichment analysis**: identify the gene ontology (GO) terms or biological pathways that are associated with the annotated genes
+ **Motif analysis**: identify the enriched DNA motifs within the peaks to understand the binding preference of the target protein
+ **Differential binding analysis**: compare data obtained from different conditions or samples to identify differentially bound regions
+ **Visualization**: generate various plots, heatmaps, and _etc._ to visualize and compare the distribution of peaks relative to the genomic features
+ Integration with other data: integrate binding results (peak data) with other omics data such as gene expression data to gain a more comprehensive view of the gene regulation mechanisms.

Various algorithms have been developed and published to identify peaks from experimental data [@thomas2017]. Once the peak files are obtained, they are commonly converted into formats like [`BED`](https://en.wikipedia.org/wiki/BED_(file_format)) or [`bigWig`](https://genome.ucsc.edu/goldenpath/help/bigWig.html). These formats allow the data to be easily loaded into genome browsers, such as the UCSC Genome Browser, as custom tracks. This enables investigators to examine the proximity of the peaks to different genomic features like genes, exons, or other conserved elements. However manually navigating through the genome browser can be a daunting task due to the typically large number of peaks that are spread across the genome.

The _Bioconductor_ package `r Biocpkg("ChIPpeakAnno")` is a pioneering tool that facilitates the batch annotation of peaks obtained from various technologies that result in a large number of enriched genomic regions. One notable feature of `r Biocpkg("ChIPpeakAnno")` is its ability to dynamically retrieve up-to-date annotations by leveraging the `r Biocpkg("biomRt")` package. This ensures that users have access to the most current annotation information. Additionally, users have the flexibility to provide their own annotation data or utilizing existing annotation packages. Furthermore, `r Biocpkg("ChIPpeakAnno")` provides functions to retrieve sequences surrounding the peaks, which can be utilized for peak validation and motif discovery [@Durinck2005]. The package also facilitates the identification of enriched GO or pathway terms associated with the peaks. Moreover, `r Biocpkg("ChIPpeakAnno")` includes several helper functions that aid in visualizing binding patterns and comparing peak profiles across multiple samples or experimental conditions.

`r Biocpkg("ChIPpeakAnno")` has been continuously enhanced since its initial release in 2010, as evident from its active development^[https://github.com/jianhong/ChIPpeakAnno/blob/devel/NEWS]. New features are regularly added based on user requests (Section \@ref(newfeature)). If you have any questions regarding its usage, please search for answers or post new questions on the [Bioconductor Support Site](https://support.bioconductor.org/new/post/). Additionally, if you have any suggestions for novel features, encounter any bugs, or wish to contribute in any way, please feel free to raise an issue or submit a pull request on the [ChIPpeakAnno](https://github.com/jianhong/ChIPpeakAnno) GitHub repository. Your input and contributions will be greatly appreciated and carefully considered.  

# Quick demo
This section provides an example on utilizing `r Biocpkg("ChIPpeakAnno")` to annotate peaks identified with MACS or MACS2 (a popular peak calling tool) [@zhang2008]. 

The process of annotating peak data typically involves several steps, each of which will be demonstrated individually in the following sections:

+ Read in peak data (Section \@ref(readinpeak))
+ Evaluate peak concordance among replicates (Section \@ref(evalcon))
+ Prepare annotation data (Section \@ref(prepanno))
+ Annotate peaks with `annotatePeakInBatch` (Section \@ref(prepanno?))
+ Add additional information using `addGeneIDs` (Section \@ref(evalcon?))

In Section \@ref(newfeature) to \@ref(newfeature), we delve into detailed use cases, showcasing the versatility of `r Biocpkg("ChIPpeakAnno")` in various scenarios. Section \@ref(newfeature) to \@ref(newfeature) present a series of commonly employed analytical pipelines, offering step-by-step illustrations for different settings.

## Read in peak data {#readinpeakdemo}
The `r Biocpkg("ChIPpeakAnno")` package provides an example peak file in xls format, which is generated by _MACS_. To work with this example file, we need to locate it with `system.file` and convert it into a `GRanges` object using `toGRanges` function.

```{r}
library(ChIPpeakAnno)

macs_peak <- system.file("extdata", "MACS_peaks.xls", 
                         package = "ChIPpeakAnno")
macs_peak_gr2 <- toGRanges(macs_peak, format = "MACS")
head(macs_peak_gr2, n = 2)
```

## Prepare annotations
The section presents annotations from two sources: the [Ensembl](https://useast.ensembl.org/index.html) annotation package and the UCSC annotation package. For more information on annotation file preparation, please refer to the Section \@ref(prepanno).

### Use Ensembl annotation package
```{r}
library(EnsDb.Hsapiens.v86)

ensembl.hs86.gene <- genes(EnsDb.Hsapiens.v86)
```

### Use UCSC annotation package
```{r}
library(TxDb.Hsapiens.UCSC.hg38.knownGene)

ucsc.hg38.knownGene <- genes(TxDb.Hsapiens.UCSC.hg38.knownGene)
```

## Annotate peaks

### Use Ensembl annotation package
```{r}
macs_peak_ensembl <- annotatePeakInBatch(macs_peak_gr2, 
										 AnnotationData = ensembl.hs86.gene)
head(macs_peak_ensembl, n = 2)
```

### Use UCSC annotation package
```{r}
macs_peak_ucsc <- annotatePeakInBatch(macs_peak_gr2, 
                                      AnnotationData = ucsc.hg38.knownGene)
head(macs_peak_ucsc, n = 2)
```

For detailed information about the metadata columns in the result files, please refer to the Section \@ref(peakmeta) or use the `?annotatePeakInBatch` command. Of note, the annotated peaks do not include the _gene symbol_ by default. However, we can easily add this piece of information using the `addGeneIDs` function, as illustrated in the examples below.

## Add gene symbols
To map _gene symbols_ to the annotated feature IDs, you will need to load the organism annotation package `r Biocpkg("org.Hs.eg.db")` as it contains the necessary information. Once loaded, you can use the`addGeneIDs` function and specify `ID2Add = "symbol"` to add the _gene symbols_.

### Use Ensembl annotation package
```{r}
library(org.Hs.eg.db)

macs_peak_ensembl <- addGeneIDs(annotatedPeak = macs_peak_ensembl, 
                                orgAnn = "org.Hs.eg.db", IDs2Add = "symbol",
                                feature_id_type = "ensembl_gene_id")
head(macs_peak_ensembl, n = 2)
```

### Use UCSC annotation package
```{r}
macs_peak_ucsc <- addGeneIDs(annotatedPeak = macs_peak_ucsc, 
                             orgAnn = "org.Hs.eg.db", IDs2Add="symbol",
                             feature_id_type = "entrez_id")
head(macs_peak_ucsc, n = 2)
```

As observed, a `symbol` metadata column has been successfully added to the resulting `GRanges` object. It is crucial to ensure the correct selection of `feature_id_type` for the function to work properly. By default, `feature_id_type = "ensembl_gene_id"`.

# Read in peak data {#readinpeak}
## Convert peaks to `GRanges`
The peak files are represented as `GRanges` objects in `r Biocpkg("ChIPpeakAnno")` and various other packages. To facilitate the conversion of commonly used peak formats including `BED`, `GFF`, as well as other popular formats like _MACS_, _MACS2_ and _CSV_, we have implemented a helper function called `toGRanges`. You can type `?toGRanges` to view the complete list of supported formats. 
### Convert `GFF` to `GRanges`
```{r}
macs_peak_gff <- system.file("extdata", "GFF_peaks_hg38.gff", 
                             package = "ChIPpeakAnno")
macs_peak_gr1 <- toGRanges(macs_peak_gff, format = "GFF", header = FALSE)
head(macs_peak_gr1, n = 2)
```

### Convert `BED` to `GRanges`
```{r}
macs_peak_bed <- system.file("extdata", "MACS_output_hg38.bed", 
                             package = "ChIPpeakAnno")
macs_peak_gr2 <- toGRanges(macs_peak_bed, format = "BED", header = FALSE)
head(macs_peak_gr2, n = 2)
```

## Evaluate peak concordance among replicates {#evalcon}
Concordant peaks are those that are consistently present in the same genomic regions across replicates. These peaks exhibit a high degree of overlap or similarity in their genomic coordinates and signal intensity. The presence of concordant peaks indicates that the observed signal is likely to be true positive rather than arising from random noise or technical artifacts. 

For experiments with two or more biological replicates, there are two strategies to handle the peaks identified from each replicate.

+ Merge or combine peaks from biological replicates
	+ It method involves combining overlapping (concordant) peaks from multiple replicates into a single set of merged peaks
	+ This method reduces noise by considering the most robust and consistently enriched regions, thus, provides the most reliable and biologically meaningful information
	+ Use case: it is typically used when comparing different conditions to identify common regulatory elements or regions of differential binding
+ Take the union of peaks from biological replicates:
	+ This method involves combining all peaks from all replicates without merging or filtering
	+ This method retains all identified peaks, thus, provides a more comprehensive view of the binding landscape
	+ Use case: it is useful for identifying condition-specific or rare binding events

Investigators may choose one of these strategies based on their research questions and the quality of their data. You can obtain concordant peaks and quantitatively evaluate the significance of peak overlaps using functions provided by `r Biocpkg("ChIPpeakAnno")`.

### Find overlapping peaks for two samples
Here is a sample code that demonstrates how to obtain overlapping peaks for two peak sets. In this example, peaks are considered overlapping if they are within a distance of 1000 base pairs (`maxgap = 1000`). The code utilized the `data` function to read in two demo peak sets in `GRanges` that are bundled with `r Biocpkg("ChIPpeakAnno")`.
```{r}
data(peaks1)
data(peaks2)
head(peaks1, n = 2)
head(peaks2, n = 2)
ol <- findOverlapsOfPeaks(peaks1, peaks2, maxgap = 1000)
names(ol)
```

The `findOverlapsOfPeaks` function returns an object of class _overlappingPeaks_, which contains the following elements. These elements provide comprehensive information about the overlapping peaks and unique peaks, allowing for further visualization and interpretation of the data.

+ `venn_cnt`: an object of `VennCounts`, which can be used to draw a Venn diagram
+ `peaklist`: a list of `GRanges` objects that contains all merged overlapping peaks or unique peaks
+ `uniquePeaks`: an object of `GRanges` that consists of all unique peaks
+ `mergedPeaks`: an object of `GRanges` that consists of all merged overlapping peaks
+ `peaksInMergedPeaks`: an object of `GRanges` that consists of all peaks in each samples involved in the overlapping peaks
+ `overlappingPeaks`: a list of data frames that consists of the annotation of all overlapping peaks
+ `all.peaks`: a list of `GRanges` objects that consists the input peaks with formatted rownames

To determine the number of peaks that are unique to the `peaks1` set (i.e., not overlapping with any peaks in `peaks2`), you can use the following code:
```{r,eval = FALSE}
length(ol$peaklist[["peaks1"]])
```

Similarly for `peaks2`:
```{r}
length(ol$peaklist[["peaks2"]])
```

To obtain the merged overlapping peaks, you have two options:

+ You can use `ol$peaklist[["peaks1///peaks2"]]`, where `"peaks1///peaks2"` represents a `GRanges` object that contains all the merged overlapping peaks in `peaks1` and `peaks2`
+ Alternatively, you can use `ol$mergedPeaks` to obtain all the merged overlapping peaks from all the peak sets in `ol`. This means that if you have multiple peak sets, this command will output all the peaks that overlap with peaks from any other peak sets.
```{r}
identical(ol$peaklist[["peaks1///peaks2"]], ol$mergedPeaks)
```

### Visualize the overlappings using Venn diagram {#venn}
The output from `findOverlapsOfPeaks` can be directly fed to `makeVennDiagram` to draw a Venn diagram and evaluate the degree of overlap between peak sets. Additionally, the `makeVennDiagram` function also provides a P-value, indicating whether the observed overlapping is statistically significant or not. 
```{r, results = "hide", fig.cap = "Venn diagram showing the number of overlapping peaks for two samples"}
venn <- makeVennDiagram(ol, totalTest = 100,
                        fill = c("#009E73", "#F0E442"),
                        col = c("#D55E00", "#0072B2"),
                        cat.col = c("#D55E00", "#0072B2"))
```

The parameter _totalTest_ refers to the total number of potential peaks that are considered in the [hypergeometric test](https://en.wikipedia.org/wiki/Hypergeometric_distribution). It should be set to a value larger than the largest number of peaks in the replicates. Refer to Section \@ref(hyper_test) on how to choose _totalTest_.

In addition to hypergeometric test, an alternative function called `peakPermTest` has been implemented to circumvent the requirement of estimating the total potential binding sites for the given experiment. For more information about the `peakPermTest`, you can go to the Section (\@ref(perm_test)).

### Use other tools to plot Venn diagram
Users can choose to utilize other tools to create Venn diagram by leveraging the `ol$venn_cnt` object. The code below illustrates how to employ the third-party R package `r CRANpkg("Vennerable")` for plotting.
```{r}
if (!library(Vennerable)) {
  install.packages("Vennerable", repos="http://R-Forge.R-project.org")
  library(Vennerable)
}

n <- which(colnames(ol$venn_cnt) == "Counts") - 1
set_names <- colnames(ol$venn_cnt)[1:n]
weight <- ol$venn_cnt[, "Counts"]
names(weight) <- apply(ol$venn_cnt[, 1:n], 1, base::paste, collapse = "")
v <- Venn(SetNames = set_names, Weight = weight)
plot(v)
```

### Visualize the distribution of relative positions for overlapping peaks
As mentioned earlier, two peaks are considered as "overlapping" if their distances are within a maximum distance of 1000 bp (`maxgap = 1000`). To visualize the distribution of the relative positions of `peaks1` to `peaks2`, we can create a _pie_ chart using the `ol$overlappingPeaks` object. This object is a list that contains detailed information about the relative positions of peaks for each pair of peak sets. For instance, `ol$overlappingPeaks[["peaks1\\\peaks2"]]` is a data frame that represents the relative positions of overlapping peaks between `peaks1` and `peaks2`.
```{r}
names(ol$overlappingPeaks)
dim(ol$overlappingPeaks[["peaks1///peaks2"]])
ol$overlappingPeaks[["peaks1///peaks2"]][1:2, ]
unique(ol$overlappingPeaks[["peaks1///peaks2"]][["overlapFeature"]])
```

The column `overlapFeature` describes the relative positions of peaks between `peaks1` and `peaks2`.

+ `upstream`: the peak from `peaks1` is located upstream of the peak from `peaks2` and is within a distance of `maxgap`
+ `downstream`: the peak from `peaks1` is located downstream of the peak from `peaks2` and is within a distance of `maxgap`
+ `overlapStart`: the peak from `peaks1` overlaps with the _start_ of peak from `peaks2`
+ `overlapEnd`: the peak from `peaks1` overlaps with the _end_ of peak from `peaks2`
+ `inside`: the peak from `peaks1` is completely contained within the peak from `peaks2`
+ `includeFeature`: the peak from `peaks1` contains the entire range of the peak from `peaks2`. It is important to note that the term`Feature` here refers to the peak in `peaks2` rather than a _genomic feature_ used in peak annotation context

The utilization of a Venn diagram, in conjunction with a pie chart, enables a more comprehensive evaluation of peak concordance among biological replicates. 

### Find overlapping peaks for three samples 
The function `findOverlapsOfPeaks` allows for the analysis of up to five sets of peaks. Here is an additional example for three samples.
```{r, results = "hide", fig.small = TRUE, fig.align = "center", fig.cap = "Venn diagram showing the number of overlapping peaks for three samples"}
data(peaks3)
ol2 <- findOverlapsOfPeaks(peaks1, peaks2, peaks3, maxgap = 1000,
                           connectedPeaks="min")
venn2 <- makeVennDiagram(ol2, totalTest = 100,
                         fill = c("#CC79A7", "#56B4E9", "#F0E442"),
                         col = c("#D55E00", "#0072B2", "#E69F00"),
                         cat.col = c("#D55E00", "#0072B2", "#E69F00"))
```

chatgpt

# Prepare annotation file {#prepanno}
An annotation file contains genomic coordinates and other relevant details for various genomic features, such as genes, transcripts, promoters, and enhancers. By overlapping the peaks with coordinates in the annotation file, researchers can determine which features are enriched or associated with the peaks. This helps in understanding the functional relevance of the peaks and provides insights into the potential regulatory elements or genes involved. 

## Commonly used annotations
Popular annotation files come from two sources and are typically stored as tab-delimited format such as `GTF` and `BED`:
```{r, echo = FALSE}
library(knitr)

Resource <- c("Ensembl", "NCBI RefSeq")
Generated_by <- c("EMBL-EBI", "NCBI")
Annotation_criteria <- c("Comprehensive (most transcripts)", "Conservative (fewer transcripts)")
Gene_id_name <- c("ensembl gene ID", "NCBI Gene ID, or entrezGene ID, or entrez ID")
URL <- c("https://ftp.ensembl.org/pub/", "https://ftp.ncbi.nlm.nih.gov/refseq/")
df <- data.frame(Resource, Generated_by, Annotation_criteria, URL)

kable(df, caption = 'A table of commonly used annotation resources.')
```

In addition, [UCSC Genome Browser](https://hgdownload.soe.ucsc.edu/downloads.html) provides processed annotations based on the above resources that can be visualized with the browser. For human and mouse, there are four `GTF` files provided respectively. 
```{r, echo = FALSE}
library(knitr)

Human <- c("[hg38.ensGene.gtf.gz (outdated)](https://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/genes/hg38.ensGene.gtf.gz)", "[hg38.ncbiRefSeq.gtf.gz](https://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/genes/hg38.ncbiRefSeq.gtf.gz)", "[hg38.knownGene.gtf.gz](https://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/genes/hg38.knownGene.gtf.gz)", "[hg38.refGene.gtf.gz](https://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/genes/hg38.refGene.gtf.gz)")
Mouse <- c("[mm10.ensGene.gtf.gz](https://hgdownload.soe.ucsc.edu/goldenPath/mm10/bigZips/genes/mm10.ensGene.gtf.gz)", "[mm10.knownGene.gtf.gz](https://hgdownload.soe.ucsc.edu/goldenPath/mm10/bigZips/genes/mm10.knownGene.gtf.gz)", "[mm10.ncbiRefSeq.gtf.gz](https://hgdownload.soe.ucsc.edu/goldenPath/mm10/bigZips/genes/mm10.ncbiRefSeq.gtf.gz)", "[mm10.refGene.gtf.gz](https://hgdownload.soe.ucsc.edu/goldenPath/mm10/bigZips/genes/mm10.refGene.gtf.gz)")
Remark <- c("Based on Ensembl gene models??", "Based on RefSeq transcripts as aligned by NCBI", "Based on GENCODE gene models (should it be same as Ensembl?)", "Based on RefSeq transcripts aligned by UCSC followed by manual curation")
df <- data.frame(Human, Mouse, Remark)

kable(df, caption = "A table of UCSC Genome Browser hosted annotation files.")
```

## Official `TxDb` and `EnsDb` {#txdb_ensdb}
In _Bioconductor_, the tab-delimited files are often converted into `TxDb` or `EnsDb` class to leverage the various accessor functions (e.g. `genes`, `transcripts`) provided with each class. An accessor function is designed to retrieve the desired features from the annotation file. Both `TxDb` and `EnsDb` can be created with the tab delimited files mentioned in the above though `EnsDb` is more tailored to `Ensembl` annotations and contains additional information such as `gene_name`, `symbol`, and `gene_biotype` compared to the `TxDb` counterparts converted with _RefSeq_ or UCSC Genome Browser hosted annotations. 

Meanwhile, there is a comprehensive list of pre-built _Bioconductor_ maintained `TxDb` and `EnsDb` packages such as `r Biocpkg("TxDb.Hsapiens.UCSC.hg38.knownGene")` and `r Biocpkg("EnsDb.Hsapiens.v86")`, which are regularly updated and can be found [here](https://www.bioconductor.org/packages/release/data/annotation/). 

## Obtain `EnsDb` and `TxDb` from `AnnotationHub`
Users can also retrieve annotations with the `r Biocpkg("AnnotationHub")` package. By default, `r Biocpkg("AnnotationHub")` uses a snapshot that is matching the _Bioconductor_ that you are using, thus, might be slightly up-to-date compared to the pre-built packages. And you can switch to an earlier version^[https://bioconductor.org/packages/release/bioc/vignettes/AnnotationHub/inst/doc/AnnotationHub.html#configuring-annotationhub-objects]. Below are examples on how to obtain annotations with `r Biocpkg("AnnotationHub")`.

### Obtain `EnsDb` using `AnnotationHub`
```{r}
library(AnnotationHub)

ah <- AnnotationHub()
EnsDb_Mmusculus_all <- query(ah, pattern = c("Mus musculus", "EnsDb"))
head(EnsDb_Mmusculus_all, n = 2)
EnsDb_Mmusculus <- EnsDb_Mmusculus_all[["AH53222"]]
class(EnsDb_Mmusculus)
```

### Obtain `TxDb` using `AnnotationHub`
```{r}
TxDb_Mmusculus_all <- query(ah, pattern = c("Mus musculus", "TxDb"))
head(TxDb_Mmusculus_all, n = 2)
TxDb_Mmusculus <- TxDb_Mmusculus_all[["AH52264"]]
class(TxDb_Mmusculus)
```

## Build custom `EnsDb` and `TxDb`
To create the most up-to-date or custom `TxDb` and `EnsDb` objects, you can leverage the following functions from the `r Biocpkg("GenomicFeatures")`^[https://bioconductor.org/packages/devel/bioc/vignettes/GenomicFeatures/inst/doc/GenomicFeatures.html] and `r Biocpkg("ensembldb")`^[https://www.bioconductor.org/packages/devel/bioc/vignettes/ensembldb/inst/doc/ensembldb.html#102_Building_annotation_packages].

+ `GenomicFeatures::makeTxDbFromUCSC`
+ `GenomicFeatures::makeTxDbFromBiomart` (being phased out in favor of `makeTxDbFromEnsembl`)
+ `GenomicFeatures::makeTxDbFromEnsembl`
+ `GenomicFeatures::makeTxDbFromGFF`
+ `GenomicFeatures::makeTxDbFromGRanges`
+ `ensembldb::makeEnsemblSQLiteFromTables`
+ `ensembldb::ensDbFromGtf`
+ `ensembldb::ensDbFromGff`
+ `ensembldb::ensDbFromGRanges`

## Use `biomaRt` {#usebiomart}
The `r Biocpkg("biomaRt")` package provides an interface to the [BioMart](https://useast.ensembl.org/info/data/biomart/index.html) databases that are prominently maintained by `Ensembl`. By querying via `r Biocpkg("biomaRt")`, you can access the most up-to-date annotations that are available from `Ensembl`. Check [this vignette](https://bioconductor.org/packages/release/bioc/vignettes/biomaRt/inst/doc/accessing_ensembl.html) for details. 

`r Biocpkg("ChIPpeakAnno")` provides an helper function called `getAnnotation` for easy retrieval of desired annotations by leveraging `r Biocpkg("biomaRt")`. Below is an example.
```{r}
library(biomaRt)

listMarts()
head(listDatasets(useMart("ENSEMBL_MART_ENSEMBL")), n = 2)
mart <- useMart(biomart="ENSEMBL_MART_ENSEMBL",
                dataset="mmusculus_gene_ensembl")
anno_from_biomart <- getAnnotation(mart, featureType = "transcript")
head(anno_from_biomart, n = 2)
```
Type `?getAnnotation` for a full list of supported `featureType`.

## Convert annotations into `GRanges`
To annotate the peaks, the selected annotation file must be converted into `GRanges` class first. `r Biocpkg("ChIPpeakAnno")` provides a helper function called `toGRanges` that can convert annotations from various formats such as `GFF`, `BED`, `CSV`, `TxDb`, and `EnsDb`  into `GRanges`. Type `?toGRanges` to learn more. Below are few examples.

### Obtain `transcript` from `TxDb/EnsDb`
```{r}
library(EnsDb.Hsapiens.v86)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)

anno_ensdb_transcript <- toGRanges(EnsDb.Hsapiens.v86, 
                                   feature = "transcript")
anno_txdb_transcript <- toGRanges(TxDb.Hsapiens.UCSC.hg38.knownGene, 
                                  feature = "transcript")
head(anno_ensdb_transcript, n = 2)
head(anno_txdb_transcript, n = 2)
```

### Obtain `gene` from `TxDb/EnsDb`
```{r}
anno_ensdb_gene <- toGRanges(EnsDb.Hsapiens.v86, 
                             feature = "gene")
anno_txdb_gene <- toGRanges(TxDb.Hsapiens.UCSC.hg38.knownGene, 
                            feature = "gene")
head(anno_ensdb_gene, n = 2)
head(anno_txdb_gene, n = 2)
```

### Use accessor functions
Again, if you are working with `TxDb` or `EnsDb`, you can obtain features in `GRanges` format using the accessor functions.
```{r}
anno_ensdb_gene <- genes(EnsDb.Hsapiens.v86)
anno_ensdb_transcript <- transcripts(TxDb.Hsapiens.UCSC.hg38.knownGene)

head(anno_ensdb_gene, n = 2)
head(anno_ensdb_transcript, n = 2)
```

### Use `getAnnotation` function
The output from `getAnnotation` are in `GRanges`, refer to Section \@ref(usebiomart) for details.

# Visualize peak distributions
Plotting peak distributions helps in quality control by providing an overview of where the peaks are localized across the genome. Unexpected distributions suggest potential issues with the data. In addition, you can select appropriate annotation file depending on the distribution of your peaks. For instance, if peaks are enriched near promoters, you may focus on annotating them with nearby genes. 

## Plot peak distributions relative to genomic features
The function `binOverFeature` plots peak count distributions relative to a given genomic feature. The following example shows the distribution of peaks in `macs_peak_gr2` relative to the `gene` feature (transcription start site (TSS)).  
```{r, fig.cap = "Peak count distribution around TSSs", warning = FALSE}
annotation_data <- genes(TxDb.Hsapiens.UCSC.hg38.knownGene)
binOverFeature(macs_peak_gr2, 
               nbins = 20,
               annotationData = annotation_data,
               xlab = "peak distance from TSS (bp)", 
               ylab = "peak count", 
               main = "Distribution of aggregated peak numbers around TSS")
```

By default, `featureSite = "FeatureStart"` meaning that the distance is calculated as peak to transcription start site (TSS). The above plot indicates that peaks are enriched around the TSS, characteristic of peaks obtained from transcription factor binding experiments.

You can also plot peak distribution over multiple genomic features including exon, intron, enhancer, proximal promoter, 5' UTR and 3' in a single bar graph with `assignChromosomeRegion`.
```{r, fig.cap = "Bar graph showing peak distributions over different genomic features"}
chromosome_region <- assignChromosomeRegion(macs_peak_gr2,
                                            TxDb = TxDb.Hsapiens.UCSC.hg38.knownGene,
                                            nucleotideLevel = FALSE,
                                            precedence=c("Promoters",
                                                         "immediateDownstream", 
                                                         "fiveUTRs", 
                                                         "threeUTRs",
                                                         "Exons", 
                                                         "Introns"))
barplot(chromosome_region[["percentage"]], las = 2)
```

The argument `las = 2` is to rotate the labels by 90 degree. By default, `nucleotideLevel = FALSE` meaning that peaks will be treated as ranges when determining overlaps with genomic features. If peak intersects with multiple features, the feature assignment is determined by the order specified in `precedence`, if `precedence` not set, counts for each overlapping features will be incremented. Otherwise, if `nucleotideLevel = TRUE`, the summit of the peak (single position) will be used when determining overlaps.

## Plot peak distributions over different genomic levels
In addition to inspect the peak enrichment pattern by plotting distribution against genomic features, user can plot distributions over different genomic levels each containing multiple categories with function `genomicElementDistribution`. 

+ "Gene Level": `geneLevel`
    + "Promoter"
    + "Gene body"
    + "Distal Intergenic"
+ "Exon Level": `Exons`
    + "5' UTR"
    + "CDS"
    + "3' URT"
    + "Other exon"
+ "Exon/Intron/Intergenic": `ExonIntron`
    + "Exon"
    + "Intron"
    + "Intergenic"

Please note that peaks can be classified into multiple categories from differente levels, leading to the number of annotated features greater than the total number of peaks. At each level, since peak spans a genomic range, it may overlap with multiple categories of features. In such cases, by default (`nucleotideLevel = FALSE`), the precedence is determined by the order listed in the `labels` argument. Otherwise, if `nucleotideLevel = TRUE`, the summit of the peak (single position) will be used when determining the overlapping features. Type `?genomicElementDistribution` to learn more.

The function `genomicElementDistribution` takes either one peak object or a list of peak objects as its input. For one peak set, a pie chart will be created whereas a bar graph will be created when a list of peak sets is provided. You can also create a [UpSet](https://en.wikipedia.org/wiki/UpSet_Plot) plot with one set of peaks using the result from the function.

### Pie graph with one peak set
```{r, fig.cap = "Pie graph showing peak distributions over different genomic features"}
genomicElementDistribution(macs_peak_gr1, 
                           TxDb = TxDb.Hsapiens.UCSC.hg38.knownGene)
```

As can be seen, a good amount of peaks come from promoter regions confirming the signature of peaks obtained from transcription factor binding experiments.

### Bar graph with a list of peak sets
```{r, fig.cap = "Bar graph showing peak distributions over different genomic features"}
macs_peaks <- GRangesList(rep1 = macs_peak_gr1,
                          rep2 = macs_peak_gr2)
genomicElementDistribution(macs_peaks, 
                           TxDb = TxDb.Hsapiens.UCSC.hg38.knownGene)
```

The distribution patterns from `rep1` and `rep2` indicate a high correlation between them.

### UpSet plot with one peak set
```{r, fig.cap = "UpSet plot showing the overlappings of peak distributions among different genomic features"}
library(UpSetR)

res <- genomicElementUpSetR(macs_peak_gr1,
                            TxDb.Hsapiens.UCSC.hg38.knownGene)
upset(res[["plotData"]], 
      nsets = length(colnames(res$plotData)), 
      nintersects = NA)
```

UpSet plot can be regarded as a "high dimensional Venn diagram" that supports viewing overlappings of multiple sets. For example, in the above plot, feature set "gene body" (from "Gene Level") and "intron" (from "Exon/Intron/Intergenic") share the highest number of common peaks.

# Annotate peaks
With the annotation data, you can assign the peaks identified in your experiments to obtain nearby features of your choice like genes, transcripts, etc, using the function `annotatePeakInBatch`. This function provides extremely flexible ways to calculate the peak-to-feature distance and which features to report. For instance, by tuning the `PeakLocForDistance` and `FeatureLocForDistance`, users can control how the distances are being calculated; by tuning the `output`, users can determine how the features should be selected. Below describes them in detail. Use `?annotatePeakInBatch` to view the full list of supported options.

+ `PeakLocForDistance`: location of the peak for distance calculation
    + `middle`: (recommended) use the center of the peak
    + `start`: (default) use the 5' end (relative to plus strand) of the peak
    + `end`: use the 3' end (relative to plus strand) of the peak
    + `endMinusStart`: use the 3' end (relative to plus strand) of the peak for features on plus strand and the 5' end (relative to plus strand) of the peak for features on minus strand
+ `FeatureLocForDistance`: location of the feature for distance calculation
    + `middle`: use the center of the feature 
    + `start`: use the 5' end (relative to plus strand) of the feature
    + `end`: use the 3' end (relative to plus strand) of the feature
    + `TSS`: (default) use the 5' end (relative to plus strand) for features on the plus strand and use the 3' end (also relative to plus strand) for features on the minus strand
    + `geneEnd`: use the 3' end (relative to plus strand) for features on the plus strand and use the 5' end (also relative to plus strand) for features on the minus strand
+ `output`: criteria for feature output
    + `nearestLocation`: (default) output the features that are nearest to the peaks as calculated by the absolute value of `PeakLocForDistance - FeatureLocForDistane`
    + `overlapping`: output all features that are overlapped with the peaks within the maximum distance as specified with the `maxgap` parameter
    + `both`: output the nearest features plus any overlapping features that are not the nearest
    + `shortestDistance`: output the features that are with the shortest distance to the peaks; the "shortest distance" is determined from either ends of the feature to either ends of the peak

Below is a diagram illustrating how the distances are determined with different `output` options when `PeakLocForDistance = "start"` and `FeatureLocForDistance = "TSS"`.
```{r, fig.cap = "How to determine peak-to-feature distances with different `output` options", echo = FALSE, out.width = "100%", out.height = "100%"}
svg <- system.file("extdata", "peakToFeatureDistance.svg", package = "ChIPpeakAnno")

knitr::include_graphics(svg)
```

The following example uses `myPeakList` that comes with `r Biocpkg("ChIPpeakAnno")`. As different major genome releases (e.g. `hg19` vs `hg38`) might differ in terms of the feature coordinates, it is recommended to use an annotation file that is created with the matching genome used when generating your peak file. For `myPeakList`, the peaks were originally called against `hg18`, therefore, we need to use a matching annotation file created with `hg18`. Use `?myPeakList` to learn more about the example peak file. Alternatively, you can liftover your `myPeakList` to `hg38` coordinates with the `rtracklayer::liftOver()` function, check out "Step3" from Section \@ref(custom_pool).         

## Find the nearest features {#findnearest}
Users can annotate the peaks by assigning the nearby features to them. This can be achieved with the `output = "nearestLocation"` option. Results from this option may contain "overlapping" features as long as they are the nearest to the peaks.
```{r}
library(TxDb.Hsapiens.UCSC.hg18.knownGene)

data(myPeakList)
peak_to_anno <- myPeakList[1:100]
anno_data <- transcripts(TxDb.Hsapiens.UCSC.hg18.knownGene)

annotated_peak <- annotatePeakInBatch(peak_to_anno, 
                                      output = "nearestLocation",
                                      PeakLocForDistance = "start",
                                      FeatureLocForDistance = "TSS",
                                      AnnotationData = anno_data)
head(annotated_peak, n = 2)
```

Break down of the options:

+ `output = "nearestLocation"`: (default) 
    + output the nearest features calculated as `abs(PeakLocForDistance - FeatureLocForDistance)`. The output can consist of both "strictly nearest features (non-overlapping)" and "overlapping features" as long as it is the nearest
+ `PeakLocForDistance = "start"` (default): 
    + `"start"` means using the 5' end (relative to plus strand) of the peak to calculate the distance to features
+ `FeatureLocForDistance = "TSS"` (default): 
    + `"TSS"` means using the 5' end (relative to plus strand) for features on the plus strand and use the 3' end (also relative to plus strand) for features on the minus strand to calculate the distance to features

Break down of the resulting metadata columns:

+ `peak`: id of the peak
+ `feature`: id of the feature such as ensembl gene ID
+ `start_position`, `end_position`, `feature_strand`: feature coordinates 
+ `insideFeature`: relative location of the peak to the feature
    + `upstream`: peak resides upstream of the feature
    + `downstream`: peak resides downstream of the feature
    + `inside`: peak resides inside the feature
    + `overlapStart`: peak overlaps with the start of the feature
    + `overlapEnd`: peak overlaps with the end of the feature
    + `includeFeature`: peak includes the feature entirely
+ `distancetoFeature`: peak-to-feature distance as calculated with `abs(PeakLocForDistance - FeatureLocForDistance)`
+ `shortestDistance`: the shortest distance from either end of the peak to either end the feature
+ `fromOverlappingOrNearest`: relevant only when `output` is set to `"both"`; "nearestLocation" indicates that the feature is the closest to the peak, can overlap with the peak; "Overlapping" means that the feature overlaps with the peak and it is not the nearest; when `output` is set to `"nearestLocation"`, this column should consist of only "NearestLocation"

## Find the nearest and overlapping features {#findboth}
In addition, `annotatePeakInBatch` can also report both the nearest features as well as overlapping features by setting `output = "both"` and the `maxgap` parameter. For example, the following command outputs the nearest features plus all overlapping features that are within 5kb away.
```{r}
annotated_peak <- annotatePeakInBatch(peak_to_anno, 
                                      AnnotationData = anno_data,
                                      output = "both",
                                      maxgap = 5000)
head(annotated_peak, n = 4)
```

Now, the `fromOverlappingOrNearest` column consists of both "NearestLocation" and "Overlapping" categories.

## Visualize peak-to-feature distances
The relative location distribution of peak-to-feature can be visualized with the information stored in the `insideFeature` metadata column.
```{r, fig.cap = "Peak distribution among features"}
pie1(table(annotated_peak$insideFeature))
```

## Use custom annotation data
You can also create and pass user defined feature coordinates in `GRanges` format as `annotationData`. For example, you may come across a list of transcript factor (TF) binding sites by literature mining and would like to use it to annotate your peaks. To do so, you first need to convert the TF binding site coordinates into a `GRanges` object, then pass that object into `annotatePeakInBatch`.
```{r}
TF_binding_sites <- GRanges(seqnames = c("1", "2", "3", "4", "5", "6", "1", 
                                         "2", "3", "4", "5", "6", "6", "6", 
                                         "6", "6", "5"),
                            ranges = IRanges(start = c(967659, 2010898, 2496700, 
                                                       3075866, 3123260, 3857500,
                                                       96765, 201089, 249670, 
                                                       307586, 312326, 385750, 
                                                       1549800, 1554400, 1565000, 
                                                       1569400, 167888600),
                                             end = c(967869, 2011108, 2496920, 
                                                     3076166,3123470, 3857780,
                                                     96985, 201299, 249890, 307796, 
                                                     312586, 385960, 1550599, 
                                                     1560799, 1565399, 1571199, 
                                                     167888999),
                                             names = paste("t", 1:17, sep = "")),
                            strand = c("+", "+", "+", "+", "+", "+", "-", "-", "-", 
                                       "-", "-", "-", "+", "+", "+", "+", "+"))

annotated_peak2 <- annotatePeakInBatch(peaks1, AnnotationData = TF_binding_sites)
head(annotated_peak2, n = 2)
```

Another example of using user defined `AnnotationData` is to annotate peaks by promoters. Promoter is typically defined as the DNA sequence located immediately upstream of the transcription start site (TSS) of a gene. The specific size of a promoter can vary depending on the gene, its regulatory complexity, and the species being studied. In practice, the promoter region can be defined as 1000bp upstream and 100bp downstream from the TSS. To prepare a custom annotation file containing only promoters, users can levarage the accessor function `promoters`.
```{r}
promoter_regions <- promoters(TxDb.Hsapiens.UCSC.hg18.knownGene, 
                              upstream = 1000, downstream = 100)
head(promoter_regions, n = 2)

annotated_peak3 <- annotatePeakInBatch(peak_to_anno, 
                                       AnnotationData = promoter_regions)
head(annotated_peak3, n = 2)
```

# Add other feature IDs
Depending on the annotation file you adopted, the feature being assigned to your peaks may have different feature ID. For example, if you are annotating your peaks with `genes(TxDb.Hsapiens.UCSC.hg38.knownGene)`, the feature id that comes with your annotation file is "entrez ID"; if you are annotating your peaks with `genes(EnsDb.Hsapiens.v86)`, the feature id that comes with your annotation is "ensembl gene ID". 
```{r}
anno_txdb <- genes(TxDb.Hsapiens.UCSC.hg38.knownGene)
head(anno_txdb$gene_id, n = 5)

anno_ensdb <- genes(EnsDb.Hsapiens.v86)
head(anno_ensdb$gene_id, n = 5)
```
The feature id in your annotation file will be listed as the "feature" metadata column in your annotated peak `GRanges` object. You can find and link them to other ids such as "symbol" using `addGeneIDs` functions.

The function `addGeneIDs` can take either a vector of feature ids or an annotated peak `GRanges` object as input. It works by creating a map between input feature id and ids being linked to by leveraging either an organism annotation dataset (`OrgDb` object such as `org.Hs.eg.db`) or a BioMart dataset (`Mart` object such as `useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")`). Therefore, you need to provide the input feature id type via `feature_id_type` and the feature id types that need to be linked to via `IDs2Add` argument.

The supported `feature_id_type` and `IDs2Add` differ between `OrgDb` and `Mart`. Below summarizes the commonly used ids. Use `?addGeneIDs` to see full list of supported ids.

+ Use `OrgDb`
    + `feature_id_type`: id type for input feature 
        + "ensembl_gene_id"
        + "entrez_id"
        + "gene_symbol"
        + "gene_alias"
        + "refseq_id"
    + `IDs2Add`: id types for features to be linked to
        + "ensembl"
        + "ensembltrans"
        + "ensemblprot"
        + "entrez_id"
        + "refseq"
        + "symbol"
        
+ Use `Mart`
    + `feature_id_type`: id type for input feature, use `listFilters(mart)` to see full supported list
        + "ensembl_gene_id"
        + "ensembl_transcript_id"
        + "ensembl_exon_id"
        + "external_gene_name"
        + "entrezgene_id"
    + `IDs2Add`: id types for features to be linked to, use `listAttributes(mart)` to see full supported list
        + "ensembl_gene_id"
        + "ensembl_transcript_id"
        + "ensembl_exon_id"
        + "gene_biotype"
        + "transcript_biotype"
        + "entrezgene_id"
        + "hgnc_symbol"
        + "entrezgene_trans_name"

## Example1: find gene symbols for a vector of entrez IDs
The following example demonstrates on using `addGeneIDs` function to find gene symbols for a vector of entrez IDs with `OrgDb`. Of note that the `"org.Hs.eg.db"` must be quoted.
```{r}
library(org.Hs.eg.db)

entrez_ids <- head(ucsc.hg38.knownGene$gene_id, n = 10)
print(entrez_ids)

res <- addGeneIDs(entrez_ids, 
                  orgAnn = "org.Hs.eg.db", 
                  feature_id_type = "entrez_id",
                  IDs2Add = "symbol")
head(res, n = 3)
```

## Example2: add gene symbols to annotated peaks
For this example, we annotate the `macs_peak_gr2` (obtained in Section \@ref(readinpeak)) using transcript information from `TxDb`, and add gene symbols to them.
```{r}
txdb.hg38.transcript <- transcripts(TxDb.Hsapiens.UCSC.hg38.knownGene)
head(txdb.hg38.transcript, n = 4)
head(names(txdb.hg38.transcript), n = 4)
```

Looks like `txdb.hg38.transcript` has a `tx_name` metadata column that contains the Ensembl transcript ids, however, `annotatePeakInBatch` requires this piece of information to be stored as `names(txdb.hg38.transcript)` so as to generate annotated peaks that is compatible with `addGeneIDs`. Therefore, we need to extract transcript ids and assign them as names first.
```{r}
tr_id <- txdb.hg38.transcript$tx_name
tr_id <- sub("\\..*$", "", tr_id) # get rid of the trailing version number
names(txdb.hg38.transcript) <- tr_id
head(txdb.hg38.transcript, n = 4)
```

Now, we can annotate `macs_peak_gr2` with `annotatePeakInBatch`.
```{r}
res <- annotatePeakInBatch(macs_peak_gr2, 
                           AnnotationData = txdb.hg38.transcript)
head(res, n = 2)
```

The resulting`feature` column has ensembl transcript ids as expected. Next, we use the `Mart` option to add gene symbols.
```{r}
library(biomaRt)

mart <- useMart(biomart = "ENSEMBL_MART_ENSEMBL",
                dataset = "hsapiens_gene_ensembl")
res <- addGeneIDs(res, 
                  mart = mart,
                  feature_id_type = "ensembl_transcript_id",
                  IDs2Add = "hgnc_symbol")
head(res, n = 2)
```

Use `?listMarts` to show available `biomart` and use `?listDatasets` to show available `dataset`. Be aware that, unlike using `OrgDb` option, we must supply `hgnc_symbol` instead of `symbol` for the `IDs2Add` argument.

# Enrichment analysis
Performing enrichment analysis is a crucial step that helps to determine whether certain biological processes, pathways, or functional categories are over-represented among the genes associated with ChIP-seq peaks. In other words, it provides functional implications to the annotated peaks by `annotatePeakInBatch`. Gene ontology (GO) and pathway enrichment are two commonly practiced methods for enrichment analysis. They provide insights into gene functions at different levels. 

The _Gene Ontology_ is a structured vocabulary that categorizes genes and their products into three main categories, namely, _Molecular Function_ (what it does), _Biological Process_ (why it does it), and _Cellular Component_ (where it does it). A pathway, on the other hand, refers to a set of predefined genes that are involved in a coordinated sequence of molecular events or cellular processes that collectively perform a specific biological function. Examples of biological pathways include "Glycolysis pathway", which is a metabolic pathway that breaks down glucose into pyruvate; and "MAPK signaling pathway", which is a signal transduction pathway involved in cell proliferation, differentiation, and response to external stimuli. While GO enrichment analysis provides more general insights, pathway analysis focuses specifically on predefined pathways. Both methods are commonly practiced and can be achieved with the `getEnrichedGO` and `getEnrichedPATH` functions provided with `r Biocpkg("ChIPpeakAnno")`.

In the following demonstration, we extract a subset peak (first 200) from `macs_peak_gr2` (obtained in Section \@ref(readinpeakdemo)), annotate them with genes from `TxDb` and perform GO and pathway enrichment analysis. In real situation, full set should be used.

```{r}
anno_data <- genes(TxDb.Hsapiens.UCSC.hg38.knownGene)
annotated_peak4 <- annotatePeakInBatch(macs_peak_gr2[1:200],
                                       AnnotationData = anno_data,
                                       output = "both",
                                       maxgap = 5000)

enriched_go <- getEnrichedGO(annotated_peak4, 
                             orgAnn = "org.Hs.eg.db", 
                             feature_id_type = "entrez_id",
                             multiAdjMethod = "BH")
```

Be aware that the `"org.Hs.eg.db"` must be quoted, and the `feature_id_type` must match the id type stored in the `feature` metadata column of your annotated peak object. If you are using genes from `TxDb` for peak annotation, the `feature` is likely `entrez_id`. When using genes from `EnsDb` for annotation, the `feature` should be `ensembl_gene_id`. Below is to show the number of enriched GO terms in each category, "bp" is for "biological process", "cc" is for "cellular component", and "mf" is for "molecular function". 
```{r}
length(enriched_go[["bp"]][["go.id"]])
length(enriched_go[["cc"]][["go.id"]])
length(enriched_go[["mf"]][["go.id"]])
```

Using the subset of annotated `macs_peak_gr2` leads to zero enriched GO term under the "bp" and "cc" categories, and 6 hits under the "mf" category.
```{r}
head(enriched_go[["mf"]], n = 2)
```

For pathway analysis, there are at least two popular databases, namely, _Reactome_ and _KEGG (Kyoto Encyclopedia of Genes and Genomes)_. While _Reactome_ is renowned for its detailed and expert-curated information, _KEGG_ provides a broader scope of information including pathways, diseases, drugs, and more organisms. The function `getEnrichedPATH` can use either database by specifying the `pathAnn` parameter. The built-in dataset `annotatedPeaks` will be used for demonstration. Be aware that `feature_id_type = "ensembl_gene_id"` for this dataset. Use `?annotatePekas` to learn more.
```{r, fig.cap = "Bar graph showing enriched pathways"}
library(reactome.db)

data(annotatedPeak)
enriched_path <- getEnrichedPATH(annotatedPeak,
                                 orgAnn = "org.Hs.eg.db",
                                 feature_id_type = "ensembl_gene_id",
                                 pathAnn = "reactome.db")
```

To use _KEGG_ database, simply set `pathAnn = "KEGGREST"`. To visualize the enriched pathways, use `enrichmentPlot` function.
```{r}
enrichmentPlot(enriched_path)
```

The function `getEnrichedGO` and `getEnrichedPATH` require an `OrgDb` annotation package to work, for less common species that are without a valid `OrgDb`, users can refer to [this post](https://support.bioconductor.org/p/9153901/#9153953) for alternative methods.

# Motif analysis
A sequence motif is a recurring pattern in DNA that is thought to have a biological function. They usually indicate binding sites for proteins including transcription factors (TF), others play a role at the RNA level such as ribosome binding and transcription termination. For peaks associated with epigenetic markers, motif analysis helps to identify candidate transcription factors. For peaks obtained through experiments such as transcription factor ChIP-seq, motif analysis facilitates the validation of expected binding factors, meanwhile, unanticipated motifs suggest cofactors. 

`r Biocpkg("ChIPpeakAnno")` provides several functions that are related to motif analysis, details see below.
    + `getAllPeakSequence`: obtain genomic sequences around peaks
        + Obtained sequences can be used for motif discovery or PCR validation
    + `oligoSummary`: find consensus sequences (motifs) in peak sequences
    + `summarizePatternInPeaks`: check if given motifs appear in peak sequences

## Obtain sequences surrounding the peaks
Here is an example to retrieve the peak sequences plus 20bp upstream and 20bp downstream for `macs_peak_gr2` peaks obtained in Section \@ref(readinpeak).
```{r}
library(BSgenome.Hsapiens.UCSC.hg38)

sequence_around_peak <- getAllPeakSequence(macs_peak_gr2, 
                                           upstream = 20,
                                           downstream = 20, 
                                           genome = BSgenome.Hsapiens.UCSC.hg38)
head(sequence_around_peak, n = 2)
```

The `genome` argument accepts either a `BSgenome` object or a `Mart` object. Again, the genome version must match the one used for creating the peak file. For full list of `BSgenome`, check out this [site](https://www.bioconductor.org/packages/release/data/annotation/). The following example demonstrates on how to use `Mart`. Refer to Section \@ref(usebiomart) for more on `Mart`. Be aware that this option is slower than using the `BSgenome` as it will query the `BioMart` for annotations on the fly if `AnnotationData` is not set.
```{r}
library(biomaRt)

mart <- useMart(biomart="ENSEMBL_MART_ENSEMBL",
                dataset="hsapiens_gene_ensembl")

sequence_around_peak <- getAllPeakSequence(macs_peak_gr2[1], 
                                           upstream = 20,
                                           downstream = 20, 
                                           genome = mart)
```

To save the sequences into _fastq_, use function `write2FASTA`.
```{r}
write2FASTA(sequence_around_peak, file = "macs_peak_gr2.fa")
```

## Discover consensus sequences (motifs) in the peaks 
The function `oligoSummary` adopts Markov models to determine whether a motif is enriched in a set of sequences compared to background. Therefore, we first need to estimate the frequencies for all combinations of oligonucleotide at given length in the background. This can be achieved with `oligoFrequency`. In the following example, we attempt to discover consensus sequences of length 6.
```{r}
freqs <- oligoFrequency(BSgenome.Hsapiens.UCSC.hg38$chr1)
motif_summary <- oligoSummary(sequence_around_peak, 
                              oligoLength = 6,
                              MarkovOrder = 3,
                              freqs = freqs,
                              quickMotif = TRUE)
```

Break down of the arguments:

+ `oligoLength`: search for motifs with this length
+ `MarkovOrder`: the order of a Markov chain that determines the extent to which the current state in the chain is dependent on previous states; simply put, a zero-order Markov chain does not consider any context or dependencies between adjacent elements while higher-order Markov chains capture longer-range dependencies in sequences and are better suited for modeling more complex sequence patterns
+ `freqs`: background motif frequencies used for Markov model
+ `quickMotif`: generate the motif matrices or not

The resulting `motif_summary` is a list containing three elements:

+ `zscore`: the Z-score of each oligonucleotide quantifies how many standard deviations the observed count is from the expected count; a high positive score suggests that the motif is significantly over-represented in the peak
+ `counts`: the count numbe of each oligonucleotide
+ `motifs`: a list of motif matrices when `quickMotif = TRUE`

We can use histogram (`hist`) to visualize the resulting Z-scores and add labels with the `text` function. Below, we label the name of the motif that has the highest Z-score.
```{r, fig.cap = "Histogram showing Z-score distribution"}
zscore <- sort(motif_summary$zscore)
h <- hist(zscore, breaks = 100, main = "Histogram of Z-score")
text(x = zscore[length(zscore)], 
     y = h$counts[length(h$counts)] + 1, 
     labels = names(zscore[length(zscore)]), 
     adj = 0, 
     srt = 90)
```

You can also visualize the motif with `r Biocpkg("motifStack")` package.
```{r}
library(motifStack)

pfm <- new("pfm", mat = motif_summary$motifs[[1]],
           name = "sample motif 1")
motifStack(pfm)
```

To loop through each element in `motif_summary$motifs`, you can use the function `mapply`.
```{r, fig.cap = "Plot showing the first motif"}
pfms <- mapply(function(motif, id) { new("pfm", mat = motif, name = as.character(id)) },
               motif_summary$motifs,
               1:length(motif_summary$motifs))
        
motifStack(pfms[[1]])
```

## Scan pre-defined sequence patterns in the peaks
If you have a list of motifs (sequence patterns), you can use function `summarizePatternInPeaks` to see if they appear in the peaks or not.
```{r}
example_pattern_file <- system.file("extdata/examplePattern.fa",
                                    package = "ChIPpeakAnno")
readLines(example_pattern_file)
pattern_in_peak <- summarizePatternInPeaks(patternFilePath = example_pattern_file,
                                           BSgenomeName = BSgenome.Hsapiens.UCSC.hg38,
                                           peaks = macs_peak_gr2[1:200])
head(pattern_in_peak, n = 2)
```

## test if the pre-defined patterns are enriched in peaks
If you have a list of motifs (sequence patterns), you can use function `oligoNucleotideEnrichment` to test if they are enriched in the peaks or not.

```{r}
library(BSgenome.Hsapiens.UCSC.hg19)
example_pattern_file =system.file("extdata", "examplePattern.fa", package="ChIPpeakAnno")
peaks = GRanges(seqnames = c("chr17", "chr3", "chr12", "chr8"), 
                 IRanges(start = c(41275784, 10076141, 4654135, 31024288), 
                         end = c(41276382, 10076732, 4654728, 31024996), 
                         names = paste0("peak", 1:4)))
result <- oligoNucleotideEnrichment(filepath = example_pattern_file, 
peaks = peaks, 
genome = Hsapiens, 
methodBackground = "selectChromRandomly", 
times = 400,
alpha=0.05)
result
```

## Alternative tools
In addition to `r Biocpkg("ChIPpeakAnno")`, users can extract the sequences with `getAllPeakSequence` and leverage other tools like [MEME Suite](https://meme-suite.org/meme/doc/streme.html) for motif-based sequence analysis.

# Peak profile comparison
Given two or more peak sets from different experiments (e.g. two TFs), it might be interesting to see if the peak profiles are correlated, and if so, how does the peak patterns compare to each other. `r Biocpkg("ChIPpeakAnno")` not only provides functions to test if there is a significant overlap among multiple peak sets, but also offer visualization function for easy comparison of peak patterns.

The significance of overlap can be determined with hypergeometric test or permutation test, both are available in `r Biocpkg("ChIPpeakAnno")`. 

## Use hypergeometric test to determine overlap among peak sets {#hyper_test}
Hypergeometric test is based on the concept of hypergeometric distribution, which is a probability distribution that describes the chance of drawing a certain number of successes (k) from a sample of size n, given a finite population (N) that contains K successes when sampling without replacement. The null hypothesis is that the sample is drawn randomly from the population, which means that the two peak sets do not overlap. A small P-value indicates that the null should be rejected and that the two peak sets overlap significantly.  

In `r Biocpkg("ChIPpeakAnno")`, the hypergeometric test is implemented in the `makeVennDiagram` function, also see Section \@ref(venn). The example below demonstrates on how to figure out the hypergeometric test P-values for peak sets from three TF ChIP-seq experiments.
```{r}
tf1 <- toGRanges(system.file("extdata/TAF.broadPeak", package = "ChIPpeakAnno"),
                 format = "broadPeak")
tf2 <- toGRanges(system.file("extdata/Tead4.broadPeak", package = "ChIPpeakAnno"),
                 format = "broadPeak")
tf3 <- toGRanges(system.file("extdata/YY1.broadPeak", package = "ChIPpeakAnno"),
                 format = "broadPeak")
```

For hypergeometric test to work, we first need to estimate the total number of binding sites, i.e. _totalTest_. The choice of _totalTest_ affects the stringency of the test, with smaller values leading to more conservative outcome (larger P-values). For practical guidance on how to choose an appropriate value for _totalTest_, you can refer to the [post](https://stat.ethz.ch/pipermail/bioconductor/2010-November/036540.html). 

For our example, we assume that potential binding regions (coding regions + promoter regions) take up 3% of the entire genome. Since the example data is from chromosome 2, we can estimate the number of total binding sites as `(length of chr24) * 3% / (mean peak length)`.
```{r, results = "hide", fig.cap = "Venn diagram1 showing overlapping peaks"}
overlapping_peaks <- findOverlapsOfPeaks(tf1, tf2, tf3, connectedPeaks="keepAll")
mean_peak_width <- mean(width(unlist(GRangesList(overlapping_peaks[["all.peaks"]]))))

total_binding_sites <- length(BSgenome.Hsapiens.UCSC.hg38[["chr2"]]) * 0.03 / mean_peak_width
venn1 <- makeVennDiagram(overlapping_peaks, 
                         totalTest = total_binding_sites, 
                         connectedPeaks = "keepAll", 
                         fill = c("#CC79A7", "#56B4E9", "#F0E442"),
                         col = c("#D55E00", "#0072B2", "#E69F00"),
                         cat.col = c("#D55E00", "#0072B2", "#E69F00"))
```

For P-values of each peak pair:
```{r}
venn1[["p.value"]]
```

For overlapping peak counts:
```{r}
venn1[["vennCounts"]]
```

The `connectedPeaks = "keepAll"` means that when multiple peaks from different groups involve in overlapping, all original peak counts for each group will be displayed in parenthesis while the minimally involved peak count will be shown outside the parenthesis. When `connectedPeaks = "keepFirstListConsistent"`, the counts from the first group will be consistently kept.
```{r, results = "hide", fig.cap = "Venn diagram2 showing overlapping peaks"}
venn2 <- makeVennDiagram(overlapping_peaks, 
                         totalTest = total_binding_sites, 
                         connectedPeaks = "keepFirstListConsistent", 
                         fill = c("#CC79A7", "#56B4E9", "#F0E442"),
                         col = c("#D55E00", "#0072B2", "#E69F00"),
                         cat.col = c("#D55E00", "#0072B2", "#E69F00"))
```

Since the P-values are all very small, the null hypothesis must be rejected, and that each pair of the peak sets overlap significantly with each other. A major drawback of this approach is that we must estimate a _totalTest_, which could dramatically affect the test outcome. For instance, if we choose "2%" over "3%" in the above example, the P-value for `tf1` vs. `tf2` becomes 0.49 so that we can no longer reject the null. To circumvent the requirement of _totalTest_, we incorporated permutation test into `peakPermTest` function.

## Use permutation test to determine overlap among peak sets {#perm_test}
The permutation test is a non-parametric test meaning that it does not require data to follow any specific distribution. The test statistic is determined according to the observed data, and the null distribution of the test statistic is estimated using a permutation (re-sampling) procedure. 

In our case, the number of overlapping peaks is considered as the test statistic, whose null distribution is estimated by first re-sampling peaks from a random peak list (the `peak pool` that represent all potential binding sites) followed by counting the number of overlapping peaks. The random peak list is generated using the distributions discovered from the input peaks, to ensure that the peak widths and relative binding positions to the features (such as `TSS` and `geneEnd`), follow the same distributions as the input peaks. When null hypothesis holds, the number of overlapping peaks are not significantly different from by chance.

The function `peakPermTest` can generate peak pool automatically given the peak binding type (`bindingType = c("TSS", "geneEnd")`), annotation type (`featureType = c("transcript", "exon")`), and annotation data (`Txdb`). Below are sample codes.
```{r}
library(TxDb.Hsapiens.UCSC.hg38.knownGene)

txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
set.seed(123)

# Example1: non-relevant peak sets
utr5 <- unique(unlist(fiveUTRsByTranscript(txdb)))
utr3 <- unique(unlist(threeUTRsByTranscript(txdb)))

utr5 <- utr5[sample.int(length(utr5), 1000)]
utr3 <- utr3[sample.int(length(utr3), 1000)]

pt1 <- peakPermTest(peaks1 = utr3, 
                    peaks2 = utr5,
                    TxDb = txdb, 
                    maxgap = 500,
                    seed = 1)
plot(pt1)
```

```{r, fig.cap = "Permutation test for non-relevant peak sets", echo = FALSE, out.width = "100%", out.height = "100%"}
png <- system.file("extdata", "permTest1.png", package = "ChIPpeakAnno")

knitr::include_graphics(png)
```

```{r}
# Example2: highly relevant peak sets
cds <- unique(unlist(cdsBy(txdb)))
ol <- findOverlaps(cds, utr3, maxgap = 1)
peaks2 <- c(cds[sample.int(length(cds), 500)],
            cds[queryHits(ol)][sample.int(length(ol), 500)])
pt2 <- peakPermTest(peaks1 = utr3,
                    peaks2 = peaks2,
                    TxDb = txdb,
                    maxgap = 500,
                    seed = 1)
plot(pt2)
```

```{r, fig.cap = "Permutation test for highly relevant peak sets", echo = FALSE, out.width = "100%", out.height = "100%"}
png <- system.file("extdata", "permTest2.png", package = "ChIPpeakAnno")

knitr::include_graphics(png)
```

As can be seen, for highly relevant peak sets, the P-value is very small. 

### Use custom peak pool {#custom_pool}
Instead of creating random peaks from input peaks, users can choose to build the `peak pool` from real binding sites obtained from experimental data with hot spots removed. Hot spots are genomic regions with high probability of being bound by many TFs in ChIP-seq experiments [@yip2008]. We suggest to remove hot spots before permutation test to avoid over-estimating the association between two input peak sets. Users are encouraged to remove [ENCODE blacklist](https://github.com/Boyle-Lab/Blacklist/tree/master/lists) regions as well. The blacklists were constructed by identifying consistently problematic regions over independent cell lines and types of experiment for each species in the ENCODE and modENCODE datasets [@encode_2012]. 

Below is an example to create a `peak pool` for human genome using the transcription factor binding site clusters downloaded from [ENCODE](https://hgdownload.cse.ucsc.edu/goldenpath/hg38/encRegTfbsClustered/). The following steps serve as an example.

+ Step1: download TF binding sites
+ Step2: download hot spots
+ Step3: liftover hot spots to hg38 (if necessary)
+ Step4: select peak sets to test
+ Step5: remove hot spots from binding pool
+ Step6: perform permutation test

```{r}
# Step1: download TF binding sites
temp <- tempfile()
download.file(file.path("https://hgdownload.cse.ucsc.edu/",
                        "goldenpath/",
                        "hg38/",
                        "encRegTfbsClustered/",
                        "encRegTfbsClusteredWithCells.hg38.bed.gz"), 
              temp)
df_tfbs <- read.delim(gzfile(temp, "r"), header = FALSE)
unlink(temp)

colnames(df_tfbs)[1:4] <- c("seqnames", "start", "end", "TF")
tfbs_hg38 <- GRanges(as.character(df_tfbs$seqnames),
                     IRanges(df_tfbs$start, df_tfbs$end),
                     TF = df_tfbs$TF)

# Step2: download hot spots
base_url <- "http://metatracks.encodenets.gersteinlab.org/metatracks/"

temp1 <- tempfile()
temp2 <- tempfile()
download.file(file.path(base_url, 
                        "HOT_All_merged.tar.gz"), 
              temp1)
download.file(file.path(base_url, 
                        "HOT_intergenic_All_merged.tar.gz"),
              temp2)
untar(temp1, exdir = dirname(temp1))
untar(temp2, exdir = dirname(temp1))
bedfiles <- dir(dirname(temp1), "bed$")
hot_spots_hg19 <- sapply(file.path(dirname(temp1), bedfiles), toGRanges, format = "BED")
unlink(temp1)
unlink(temp2)

names(hot_spots_hg19) <- gsub("_merged.bed", "", bedfiles)
hot_spots_hg19 <- sapply(hot_spots_hg19, unname)
hot_spots_hg19 <- GRangesList(hot_spots_hg19)

# Step3: liftover hot spots to hg38
library(R.utils)

temp_chain_gz <- tempfile()
temp_chain <- tempfile()
base_url_chain <- "http://hgdownload.cse.ucsc.edu/goldenpath/"
download.file(file.path(base_url_chain, 
                        "hg19/liftOver/",
                        "hg19ToHg38.over.chain.gz"),
              temp_chain_gz)
gunzip(filename = temp_chain_gz, destname = temp_chain)
chain_file <- import.chain(hg19_to_hg38)
unlink(temp_chain_gz)
unlink(temp_chain)

hot_spots_hg38 <- liftOver(hot_spots_hg19, chain_file)

# Step4: select peak sets to test
tfbs_hg38_by_TF <- split(tfbs_hg38, tfbs_hg38$TF)
TAF1 <- tfbs_hg38_by_TF[["TAF1"]]
TEAD4 <- tfbs_hg38_by_TF[["TEAD4"]]

# Step5: remove hot spots from binding pool
remove_ol <- function(gr, gr_hot_spots) { 
  # helper function to remove overlaps with hot_spots
  ol <- findOverlaps(gr, gr_hot_spots)
  if (length(ol) > 0) gr <- gr[-unique(queryHits(ol))]
  gr
}
tfbs_hg38 <- remove_ol(tfbs_hg38, hot_spots_hg38)
tfbs_hg38 <- reduce(tfbs_hg38)

# Step6: perform permutation test
pool <- new("permPool", 
            grs = GRangesList(tfbs_hg38), 
            N = length(TAF1))
pt3 <- peakPermTest(TAF1, TEAD4, pool = pool, ntimes = 500)
plot(pt3)
```

```{r, fig.cap = "Permutation test using custom peak pool", echo = FALSE, out.width = "100%", out.height = "100%"}
png <- system.file("extdata", "permTest3.png", package = "ChIPpeakAnno")

knitr::include_graphics(png)
```

## Visualize binding patterns of multiple experiments {#multi_exp}
If you have peak files obtained from multiple TF ChIP-seq experiments and would like to compare their binding patterns using raw signals such as read coverage. `r Biocpkg("ChIPpeakAnno")` provides two functions, `featureAlignedHeatmap` and `featureAlignedDistribution`, to visualize their binding patterns side-by-side.

To demonstrate, we first need to prepare both the peak data and coverage information (`bigWig`). Four steps are involved.

+ Step1: read in example peak files
+ Step2: find peaks that are shared by all
+ Step3: read in example coverage files
+ Step4: visualize

```{r, fig.cap = "Heatmap of coverage densities for selected TFs"}
# Step1: read in example peak files
extdata_path <- system.file("extdata", package = "ChIPpeakAnno")
broadPeaks <- dir(extdata_path, "broadPeak")
gr_TFs <- sapply(file.path(extdata_path, broadPeaks), toGRanges, format = "broadPeak")
names(gr_TFs) <- gsub(".broadPeak", "", broadPeaks)
names(gr_TFs)
```
Now, we have read in peak files for three TFs ("TAF", "Tead", "YY1") into `gr_TFs` object. Next step is to find overlapping peaks to ensure that we are comparing binding patterns over the same genomic regions.

```{r}
# Step2: find peaks that are shared by all
ol <- findOverlapsOfPeaks(gr_TFs)
gr_TFs_ol <- ol$peaklist$`TAF///Tead4///YY1`

# Step3: read in example coverage files
# here we read in coverage data from -2000bp to -2000bp of each shared peak center
TF_width <- width(gr_TFs_ol)
gr_TFs_ol_center <- gr_TFs_ol
start(gr_TFs_ol_center) <- start(gr_TFs_ol) + floor(TF_width/2) - 2000
end(gr_TFs_ol_center) <- start(gr_TFs_ol) + floor(TF_width/2) + 2000

bigWigs <- dir(extdata_path, "bigWig")
coverage_list <- sapply(file.path(extdata_path, bigWigs), 
                        import, # rtracklayer::import
                        format = "BigWig",
                        which = gr_TFs_ol_center,
                        as = "RleList")

names(coverage_list) <- gsub(".bigWig", "", bigWigs)
names(coverage_list)
```

```{r, fig.cap = "Heatmap of coverages for selected TFs", fig.height = 6, message = FALSE}
sig <- featureAlignedSignal(coverage_list, gr_TFs_ol_center)
featureAlignedHeatmap(sig, gr_TFs_ol_center,
                      upper.extreme=c(3, 0.5, 4))
```

```{r, fig.cap = "Distribution of coverage densities for selected TFs", message = FALSE}
featureAlignedDistribution(sig, gr_TFs_ol_center,
                           type = "l")
```

# Common workflow 1: single TF with replicates
For experiments targeting a single TF with replicates, a common analytic strategy is outlined below.

+ Step1: import data
  + Convert `BED/GFF` files into `GRanges`
  + Find overlapping peaks among replicates
  + Add metadata (optional)
  + Visualize replicate concordance using Venn diagram
+ Step2: prepare annotation file
+ Step3: visualize peak distribution
+ Step4: annotate peaks
+ Step5: find possible enhancers
+ Step6: find peaks with bi-directional promoters
+ Step7: enrichment analysis
+ Step8: motif analysis

## Step1: import data
Common peak formats such as `BED`, `GFF`, and `MACS` can be converted into `GRanges` format using `toGRanges` function. After importing the data, concordance across peak replicates can be evaluated with `findOverlapsOfPeaks` and `makeVennDiagram`. In addition, the meta data columns will be dropped for the merged overlapping peaks. To add them back, we can leverage the `addMetadata` function. For example, `addMetadata(ol, colNames = "score", FUN = mean)` will add "score" column to each merged overlapping peak by taking the mean score of overlapping peaks involved.
```{r, message = FALSE, warning = FALSE}
library(ChIPpeakAnno)

# Convert BED/GFF into GRanges
bed1 <- system.file("extdata", "MACS_output_hg38.bed", 
                    package = "ChIPpeakAnno")
gr1 <- toGRanges(bed1, format = "BED", header = FALSE)
gff1 <- system.file("extdata", "GFF_peaks_hg38.gff", 
                    package = "ChIPpeakAnno")
gr2 <- toGRanges(macs_peak_gff, format = "GFF", header = FALSE)

# Find overlapping peaks
ol <- findOverlapsOfPeaks(gr1, gr2)

# Add "score" meta column to overlapping peaks
ol <- addMetadata(ol, colNames = "score", FUN = mean) 
head(ol$mergedPeaks, n = 2)
```

```{r, results = "hide", fig.cap = "Venn diagram showing the number of overlapping peaks for gr1 and gr2"}
venn <- makeVennDiagram(ol,
                        fill = c("#009E73", "#F0E442"),
                        col = c("#D55E00", "#0072B2"),
                        cat.col = c("#D55E00", "#0072B2"))
```

For P-value of hypergeometric test:
```{r}
venn[["p.value"]]
```

For overlapping peak counts:
```{r}
venn[["vennCounts"]]
```
As can be seen, the extremely small P-value suggests that the two peak sets are highly relevant, reflecting a good consistency among experimental replicates.

## Step2: prepare annotation file
As with the peak files, the annotation file must be converted into a `GRanges` object. Annotation `GRanges` can be constructed from not only `BED`, `GFF`, user defined txt files, but also`EnsDb`, `TxDb` objects with `toGRanges` function. For `EnsDb` and `TxDb` object, annotation can also be prepared with accessor functions, more see Section \@ref(txdb_ensdb). Note that the version of genome used for creating the annotation file must match with the genome used for peak calling because the feature coordinates may vary across different genome releases. For example, if you are using `Mus_musculus.v103` for mapping, youd best use `EnsDb.Mmusculus.v103` for annotation. 

The following example converts feature genes from `EnsDb` to annotation data using accessor function.
```{r}
library(EnsDb.Hsapiens.v86)

ensembl.hs86.gene <- genes(EnsDb.Hsapiens.v86)
head(ensembl.hs86.gene, n = 2)
```

## Step3: visualize peak distribution
Now given merged overlapping peaks and annotation data, we can visualize the distribution of the distance of merged peaks to the nearest features such as genes (TSSs) by `binOverFeature` function.
```{r, fig.cap = "Peak count distribution around transcription start sites", warning = FALSE}
binOverFeature(ol$mergedPeaks, 
               nbins = 20,
               annotationData = ensembl.hs86.gene,
               xlab = "peak distance from TSSs (bp)", 
               ylab = "peak count", 
               main = "Distribution of aggregated peak numbers around TSS")
```

We can also use `genomicElementDistribution` to summarize the distribution of peaks over different types of genomic features such "exon", "intron", "enhancer", "UTR", etc. When inputting a single peak file, a pie graph will be created.
```{r, fig.cap = "Pie graph showing peak distributions over different genomic features"}
library(TxDb.Hsapiens.UCSC.hg38.knownGene)

genomicElementDistribution(ol$mergedPeaks, 
                           TxDb = TxDb.Hsapiens.UCSC.hg38.knownGene)
```

When inputting a peak list, a bar graph will be created

As can be seen, a good amount of peaks come from promoter regions confirming the signature of peaks obtained from transcription factor binding experiments.

### Bar graph with a list of peak sets
```{r, fig.cap = "Bar graph showing peak distributions over different genomic features"}
macs_peaks <- GRangesList(rep1 = macs_peak_gr1,
                          rep2 = macs_peak_gr2)
genomicElementDistribution(macs_peaks, 
                           TxDb = TxDb.Hsapiens.UCSC.hg38.knownGene)
```


```{}

## Step4: annotate peaks
## Step5: find possible enhancers
## Step6: find peaks with bi-directional promoters
## Step7: enrichment analysis
## Step8: motif analysis



This section streamlines the common analysis performed with a single TF


# Common workflow 2: multiple TFs

## goals {.unnumbered}
* goal1
* goal2
* goal3

# Common workflow 2: multiple TF
## goals {.unnumbered}
## step2:

# Common workflow 3:

# Selected Q & A
For usage questions, post to bioconductor support site [here]().
For new feature request or bug report, create a GitHub issue [here]().

## 1. How to xxx?

## 2. How to xxx?

# How to cite `r Biocpkg("ChIPpeakAnno")`

# Session info

Here is the output of `sessionInfo()` on the system on which this document was
compiled running pandoc `r rmarkdown::pandoc_version()`:

```{r sessionInfo, echo = FALSE}
sessionInfo()
```

Some stats:
> length(tfbs_hg19)
[1] 4380444
> length(reduce(tfbs_hg19))
[1] 746157
> length(reduce(remove_ol(tfbs_hg19, hot_spots_hg19)))
[1] 617916
> length(remove_ol(tfbs_hg19, hot_spots_hg19))
[1] 1537048

when creating pool, if grs not reduced(). the P-value would become 1; also, the N arg when creating pool must match the A set in peakPermTest: the following results differ:
<!-- pool8 <- new("permPool", grs=GRangesList(wgEncodeTfbsV3), N=length(TEAD4)) -->
<!-- pt8 <- peakPermTest(TEAD4, TAF1, pool=pool8, ntimes=50) -->
<!-- pt8x <- peakPermTest(TAF1, TEAD4, pool=pool8, ntimes=50) -->
However, the following seem to generate comparable results, so what exactly if N in permPool?
<!-- pool81 <- new("permPool", grs=GRangesList(wgEncodeTfbsV3), N=length(TAF1)) -->
<!-- pt81 <- peakPermTest(TEAD4, TAF1, pool=pool81, ntimes=50) -->
<!-- pt81x <- peakPermTest(TAF1, TEAD4, pool=pool81, ntimes=50) -->


